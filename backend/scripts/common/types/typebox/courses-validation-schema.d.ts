/**
 * ATTENTION. This code was AUTO GENERATED by ts2typebox. While I don't know
 * your use case, there is a high chance that direct changes to this file get
 * lost. Consider making changes to the underlying Typescript code you use to
 * generate this file instead. The default file is called "types.ts", perhaps
 * have a look there! :]
 */

import { Type, Static } from "@sinclair/typebox";

export type paths = Static<typeof paths>;
export const paths = Type.Object({
  "/v4/courses": Type.Object({
    get: Type.Index(operations, Type.Literal("findCourseCollectionUsingGET")),
  }),
  "/v4/courses/{id}": Type.Object({
    get: Type.Index(operations, Type.Literal("findCourseByIdUsingGET")),
  }),
});

export type definitions = Static<typeof definitions>;
export const definitions = Type.Recursive((This) =>
  Type.Object({
    coursesPayload: Type.Object({
      apiResponse: Type.Optional(
        Type.Index(definitions, Type.Literal("coursesResponse"))
      ),
    }),
    coursesResponse: Type.Intersect([
      Type.Index(definitions, Type.Literal("apiResponse")),
      Type.Object({
        responseType: Type.Optional(Type.String()),
        response: Type.Optional(
          Type.Object({
            courses: Type.Array(
              Type.Index(definitions, Type.Literal("course"))
            ),
          })
        ),
      }),
      Type.Object({
        response: Type.Unknown(),
      }),
    ]),
    errorPayload: Type.Object({
      apiResponse: Type.Optional(
        Type.Index(definitions, Type.Literal("apiResponse"))
      ),
    }),
    apiResponse: Type.Object({
      source: Type.Optional(Type.String()),
      correlationId: Type.Optional(Type.String()),
      timeStamp: Type.Optional(Type.String()),
      cursor: Type.Optional(Type.Index(definitions, Type.Literal("cursor"))),
      httpStatus: Type.Index(definitions, Type.Literal("descriptor")),
      message: Type.Optional(
        Type.Index(definitions, Type.Literal("descriptor"))
      ),
      helpResource: Type.Optional(Type.String()),
    }),
    catalogNumber: Type.Object({
      prefix: Type.Optional(Type.String()),
      number: Type.String(),
      suffix: Type.Optional(Type.String()),
      formatted: Type.String(),
    }),
    cip: Type.Object({
      code: Type.Optional(Type.String()),
      description: Type.Optional(Type.String()),
    }),
    component: Type.Object({
      instructionMethod: Type.Index(definitions, Type.Literal("descriptor")),
      primary: Type.Boolean(),
      contactHours: Type.Optional(Type.Number()),
      minContactHours: Type.Number(),
      maxContactHours: Type.Number(),
      workloadHours: Type.Optional(Type.Number()),
      finalExam: Type.Optional(
        Type.Index(definitions, Type.Literal("descriptor"))
      ),
      feesExist: Type.Optional(Type.Boolean()),
    }),
    course: Type.Object({
      identifiers: Type.Array(
        Type.Index(definitions, Type.Literal("identifier"))
      ),
      subjectArea: Type.Index(definitions, Type.Literal("descriptor")),
      catalogNumber: Type.Index(definitions, Type.Literal("catalogNumber")),
      classSubjectArea: Type.Optional(
        Type.Index(definitions, Type.Literal("descriptor"))
      ),
      displayName: Type.Optional(Type.String()),
      classDisplayName: Type.Optional(Type.String()),
      formerDisplayName: Type.Optional(Type.String()),
      title: Type.Optional(Type.String()),
      transcriptTitle: Type.Optional(Type.String()),
      description: Type.Optional(Type.String()),
      academicCareer: Type.Optional(
        Type.Index(definitions, Type.Literal("descriptor"))
      ),
      academicGroup: Type.Optional(
        Type.Index(definitions, Type.Literal("descriptor"))
      ),
      academicOrganization: Type.Optional(
        Type.Index(definitions, Type.Literal("descriptor"))
      ),
      departmentNicknames: Type.Optional(Type.String()),
      primaryInstructionMethod: Type.Optional(
        Type.Index(definitions, Type.Literal("descriptor"))
      ),
      credit: Type.Optional(Type.Index(definitions, Type.Literal("credit"))),
      gradingBasis: Type.Optional(
        Type.Index(definitions, Type.Literal("descriptor"))
      ),
      blindGrading: Type.Optional(Type.Boolean()),
      status: Type.Optional(
        Type.Index(definitions, Type.Literal("descriptor"))
      ),
      fromDate: Type.Optional(Type.String()),
      toDate: Type.Optional(Type.String()),
      createdDate: Type.Optional(Type.String()),
      updatedDate: Type.Optional(Type.String()),
      printInCatalog: Type.Optional(Type.Boolean()),
      printInstructors: Type.Optional(Type.Boolean()),
      anyFeesExist: Type.Optional(Type.Boolean()),
      finalExam: Type.Optional(
        Type.Index(definitions, Type.Literal("descriptor"))
      ),
      instructorAddConsentRequired: Type.Optional(Type.Boolean()),
      instructorDropConsentRequired: Type.Optional(Type.Boolean()),
      allowMultipleEnrollments: Type.Optional(Type.Boolean()),
      spansMultipleTerms: Type.Optional(Type.Boolean()),
      multipleTermNumber: Type.Optional(Type.Number()),
      contactHours: Type.Optional(Type.Number()),
      workloadHours: Type.Optional(Type.Number()),
      enrollmentUnitLoadCalculator: Type.Optional(
        Type.Index(definitions, Type.Literal("descriptor"))
      ),
      tie: Type.Optional(Type.Index(definitions, Type.Literal("tie"))),
      cip: Type.Optional(Type.Index(definitions, Type.Literal("cip"))),
      hegis: Type.Optional(Type.Index(definitions, Type.Literal("hegis"))),
      repeatability: Type.Optional(
        Type.Index(definitions, Type.Literal("repeatability"))
      ),
      preparation: Type.Optional(
        Type.Index(definitions, Type.Literal("preparation"))
      ),
      requisites: Type.Optional(
        Type.Index(definitions, Type.Literal("descriptor"))
      ),
      creditRestriction: Type.Optional(
        Type.Index(definitions, Type.Literal("creditRestriction"))
      ),
      courseObjectives: Type.Optional(Type.Array(Type.String())),
      studentLearningOutcomes: Type.Optional(Type.Array(Type.String())),
      proposedInstructors: Type.Optional(Type.Array(Type.String())),
      formatsOffered: Type.Optional(
        Type.Index(definitions, Type.Literal("formatsOffered"))
      ),
      crossListing: Type.Optional(
        Type.Index(definitions, Type.Literal("crossListing"))
      ),
      classCrossListing: Type.Optional(
        Type.Index(definitions, Type.Literal("crossListing"))
      ),
      requirementsFulfilled: Type.Optional(
        Type.Array(
          Type.Index(definitions, Type.Literal("requirementFulfilled"))
        )
      ),
    }),
    credit: Type.Object({
      type: Type.String(),
      value: Type.Index(definitions, Type.Literal("creditValue")),
    }),
    creditDiscrete: Type.Object({
      units: Type.Array(Type.Number()),
    }),
    creditFixed: Type.Object({
      units: Type.Number(),
    }),
    creditRange: Type.Object({
      minUnits: Type.Number(),
      maxUnits: Type.Number(),
    }),
    creditRestriction: Type.Object({
      restrictionText: Type.Optional(Type.String()),
      restrictionCourses: Type.Optional(
        Type.Array(
          Type.Index(definitions, Type.Literal("creditRestrictionCourse"))
        )
      ),
    }),
    creditRestrictionCourse: Type.Object({
      course: Type.Index(definitions, Type.Literal("minimalCourse")),
      maxCreditPercentage: Type.Number(),
    }),
    creditValue: Type.Object({
      fixed: Type.Optional(
        Type.Index(definitions, Type.Literal("creditFixed"))
      ),
      range: Type.Optional(
        Type.Index(definitions, Type.Literal("creditRange"))
      ),
      discrete: Type.Optional(
        Type.Index(definitions, Type.Literal("creditDiscrete"))
      ),
    }),
    crossListing: Type.Object({
      count: Type.Number(),
      courses: Type.Array(Type.String()),
    }),
    cursor: Type.Object({
      previous: Type.Optional(Type.String()),
      next: Type.Optional(Type.String()),
    }),
    descriptor: Type.Object({
      code: Type.Optional(Type.String()),
      description: Type.Optional(Type.String()),
      formalDescription: Type.Optional(Type.String()),
      active: Type.Optional(Type.Boolean()),
      fromDate: Type.Optional(Type.String()),
      toDate: Type.Optional(Type.String()),
    }),
    format: Type.Object({
      termsAllowed: Type.Array(
        Type.Index(definitions, Type.Literal("termName"))
      ),
      sessionType: Type.String(),
      description: Type.Optional(Type.String()),
      aggregateContactHours: Type.Optional(Type.Number()),
      aggregateMinContactHours: Type.Number(),
      aggregateMaxContactHours: Type.Number(),
      minWorkloadHours: Type.Number(),
      maxWorkloadHours: Type.Number(),
      anyFeesExist: Type.Optional(Type.Boolean()),
      finalExam: Type.Optional(
        Type.Index(definitions, Type.Literal("descriptor"))
      ),
      components: Type.Optional(
        Type.Array(Type.Index(definitions, Type.Literal("component")))
      ),
    }),
    formatsOffered: Type.Object({
      description: Type.Optional(Type.String()),
      formats: Type.Array(Type.Index(definitions, Type.Literal("format"))),
      typicallyOffered: Type.Optional(
        Type.Index(definitions, Type.Literal("typicallyOffered"))
      ),
      summerOnly: Type.Optional(Type.Boolean()),
    }),
    hegis: Type.Object({
      code: Type.Optional(Type.String()),
      description: Type.Optional(Type.String()),
    }),
    identifier: Type.Object({
      type: Type.String(),
      id: Type.String(),
      primary: Type.Optional(Type.Boolean()),
      disclose: Type.Optional(Type.Boolean()),
      fromDate: Type.Optional(Type.String()),
      toDate: Type.Optional(Type.String()),
    }),
    minimalCourse: Type.Object({
      identifiers: Type.Array(
        Type.Index(definitions, Type.Literal("identifier"))
      ),
      subjectArea: Type.Optional(
        Type.Index(definitions, Type.Literal("descriptor"))
      ),
      catalogNumber: Type.Optional(
        Type.Index(definitions, Type.Literal("catalogNumber"))
      ),
      displayName: Type.String(),
    }),
    preparation: Type.Object({
      recommendedText: Type.Optional(Type.String()),
      recommendedCourses: Type.Optional(
        Type.Array(Type.Index(definitions, Type.Literal("minimalCourse")))
      ),
      requiredText: Type.Optional(Type.String()),
      requiredCourses: Type.Optional(
        Type.Array(Type.Index(definitions, Type.Literal("minimalCourse")))
      ),
    }),
    repeatability: Type.Object({
      repeatable: Type.Boolean(),
      description: Type.Optional(Type.String()),
      maxCredit: Type.Optional(Type.Number()),
      maxCount: Type.Optional(Type.Number()),
    }),
    requirementFulfilled: Type.Object({
      code: Type.Optional(Type.String()),
      description: Type.Optional(Type.String()),
    }),
    termName: Type.String(),
    tie: Type.Object({
      code: Type.Optional(Type.String()),
      description: Type.Optional(Type.String()),
    }),
    typicallyOffered: Type.Object({
      terms: Type.Optional(
        Type.Array(Type.Index(definitions, Type.Literal("termName")))
      ),
      comments: Type.Optional(Type.String()),
    }),
    units: Type.Number(),
  })
);

export type parameters = Static<typeof parameters>;
export const parameters = Type.Object({
  "page-number": Type.Number({
    description:
      "The set of records to return; can be used to traverse paginated data sets.",
    default: 1,
  }),
  "page-size": Type.Number({
    description:
      "The number of records returned in one paginated data set. Maximum is 100",
    default: 50,
  }),
  app_id: Type.String(),
  app_key: Type.String({
    description: "The private key portion of API Central credentials",
  }),
});

export type operations = Static<typeof operations>;
export const operations = Type.Object({
  findCourseCollectionUsingGET: Type.Object({
    parameters: Type.Object({
      query: Type.Object({
        "status-code": Type.Optional(Type.String()),
        "subject-area-code": Type.Optional(Type.String()),
        "catalog-number": Type.Optional(Type.String()),
        "course-prefix": Type.Optional(Type.String()),
        "course-number": Type.Optional(Type.String()),
        "academic-career-code": Type.Optional(Type.String()),
        units: Type.Optional(Type.String()),
        "summer-only": Type.Optional(Type.String()),
        "grading-basis-code": Type.Optional(Type.String()),
        "requirement-fulfilled-code": Type.Optional(Type.String()),
        "last-updated-since": Type.Optional(Type.String()),
        "sort-by": Type.Optional(
          Type.Union([
            Type.Literal("subject-area-code"),
            Type.Literal("last-updated"),
            Type.Literal("catalog-number"),
          ])
        ),
        "page-number": Type.Optional(
          Type.Index(parameters, Type.Literal("page-number"))
        ),
        "page-size": Type.Optional(
          Type.Index(parameters, Type.Literal("page-size"))
        ),
      }),
      header: Type.Object({
        app_id: Type.Index(parameters, Type.Literal("app_id")),
        app_key: Type.Index(parameters, Type.Literal("app_key")),
      }),
    }),
    responses: Type.Object({
      200: Type.Object({
        schema: Type.Index(definitions, Type.Literal("coursesPayload")),
      }),
      400: Type.Unknown(),
      401: Type.Unknown(),
      403: Type.Unknown(),
      404: Type.Unknown(),
      500: Type.Unknown(),
    }),
  }),
  findCourseByIdUsingGET: Type.Object({
    parameters: Type.Object({
      path: Type.Object({
        id: Type.String(),
      }),
      query: Type.Object({
        "id-type": Type.Optional(
          Type.Union([
            Type.Literal(""),
            Type.Literal("cms-id"),
            Type.Literal("cs-course-id"),
            Type.Literal("cms-version-independent-id"),
          ])
        ),
        "status-code": Type.Optional(Type.String()),
      }),
      header: Type.Object({
        app_id: Type.Index(parameters, Type.Literal("app_id")),
        app_key: Type.Index(parameters, Type.Literal("app_key")),
      }),
    }),
    responses: Type.Object({
      200: Type.Object({
        schema: Type.Index(definitions, Type.Literal("coursesPayload")),
      }),
      400: Type.Unknown(),
      401: Type.Unknown(),
      403: Type.Unknown(),
      404: Type.Object({
        schema: Type.Index(definitions, Type.Literal("errorPayload")),
      }),
      500: Type.Unknown(),
    }),
  }),
});

export type external = Static<typeof external>;
export const external = Type.Object({});
